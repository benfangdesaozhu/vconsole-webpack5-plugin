(()=>{var e={77:e=>{e.exports='<pre><code>本文是webpack5+vue2的项目搭建\n\nnpm i -y 初始化项目\n1、 npm i -y\n\n下载相关依赖 webpack、webpack-cli\n2、npm i webpack webpack-cli -D\n\n创建项目相关文件目录(具体可以参考项目的源码)\n3、src文件夹和webpack.config.js、和\n\n4、src目录中创建webpack的入口文件main.js和存放样式的style目录、公共资源public等目录\n\n以上是准备阶段\n\n接下来我们介绍配置阶段\n\n1、webpack.config.js中增加入口文件,出口文件，以及模式\n\nconst path = require(&quot;path&quot;)\n\nmodules.export = {\n    entry: &#39;./src/main.js&#39;,\n    output: {\n        path: path.join(__dirname, &#39;dist&#39;),\n        filename: &#39;[name].js&#39;\n    },\n    mode: &#39;development&#39;,\n}\n\n这个时候一个最基本的 打包器已经生成，在package.json的script当中添加命令&quot;build&quot;: &quot;webpack --config webpack.config.js&quot;，这个时候，我们运行npm run build就可以打包出一个dist文件。\n\n\n2、使用html-webpack-plugin插件将打包的js都引入到该html中。\n\n安装依赖：npm i --save-dev html-webpack-plugin\n\n在webpack.config.js中修改对应的配置\n\n    const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;)\n    module.export = {\n        ...\n        plugins: [ // 添加对应插件\n            new HtmlWebpackPlugin({\n                template: path.join(__dirname, &#39;./src/public/index.html&#39;)\n            })\n        ]\n    }\n\n    并且这时候修改入口文件。添加document.write(&#39;hello webpack&#39;),\n\n    添加完毕之后，运行打包命令。npm run build(每次运行之前先清掉之前的dist文件)，接着就能看到dist中有对应的html文件，打开文件，就能看到已经将打包之后的js引入到该文件中，页面上也能显示对应的hello webpack。\n\n    因为每次打包的时候都需要清除当前的dist文件，因此为了减少手动操作，我们可以使用clean-webpack-plugin这个插件进行帮忙处理\n\n        同样的安装依赖：npm install --save-dev clean-webpack-plugin\n\n        并在webpack.config.js文件中配置对应插件\n\n        const { CleanWebpackPlugin } = require(&#39;clean-webpack-plugin&#39;)\n        module.export = {\n            ...\n            plugins: [ // 添加对应插件\n                new HtmlWebpackPlugin({\n                    template: path.join(__dirname, &#39;./src/public/index.html&#39;)\n                }),\n                new CleanWebpackPlugin()\n            ]\n        }\n\n    每次修改都需要进行打包，这样太麻烦。这个时候我们可以使用webpack-dev-server的HMR来解决\n\n    在webpack.config.js\n    devServer: {\n        contentBase: path.join(__dirname, &#39;dist&#39;),\n        compress: true,\n        port: 9001,\n        hot: true,\n        open: true, // 自动打开浏览器  https://webpack.docschina.org/configuration/dev-server/#devserveropen\n    }\n\n    并在package.josn增加命令：&quot;start&quot;: &quot;webpack serve --config webpack.config.js&quot;\n\n    配置完之后，启动npm run start 之后，修改main文件的输出，即可不用刷新浏览器同步更新了。\n\n    3、html和js搞定之后，就剩css了。css比较简单，只需要添加两个loader即可，并且在配置文件中配置下即可。\n        npm i -D style-loader css-loader\n\n        webpack.config.js中配置\n        module.exports = {\n            ...,\n            module: {\n                rules: [\n                    {\n                        test: /\\.css$/,\n                        use: [&#39;style-loader&#39;, &#39;css-loader&#39;]\n                    }\n                ]\n            },\n        }\n\n        配置完成之后，只需要在入口文件中main.js引入对应的css文件就可以了。\n\n    4、安装配置并结合vue文件使用vue （参考：https://vue-loader.vuejs.org/zh/）\n\n        要能像vue-cli一样使用vue的话。需要安装vue-loader vue-template-compiler以及vue\n        vue-loader: 用于解析.vue文件\n        vue-template-compiler： 用于编译模板\n\n        npm i -D vue-loader vue-template-compiler\n        npm i -S vue\n\n        在使用模板编译的时候遇到问题。比如APP.vue中，使用&lt;style&gt;&lt;/style&gt;写对应样式，如果不写scoped的情况下，并且不指定对应css预处理器的时候，能正常编译对应样式，如果加上scoped,编译结束后，会出现&lt;style scoped&gt;&lt;/style&gt;内的样式不生效的情况（回退之后不管用了）。查看vue-loader的官方文档，发现，只需要添加postcss-loader即可\n\n            {\n                test: /\\.css$/,\n                use: [&#39;style-loader&#39;, &#39;css-loader&#39;,&#39;postcss-loader&#39;]\n            },\n        在加上预处理器之后，这里以less为介绍：\n\n            npm i less less-loader -D\n\n            {\n                test: /\\.less$/,\n                use: [\n                &#39;style-loader&#39;,\n                &#39;css-loader&#39;,\n                &#39;postcss-loader&#39;,\n                &#39;less-loader&#39;\n                ]\n            },\n        即可使用less文件和&lt;style lang=&quot;less&quot; scoped&gt;&lt;/style&gt;\n\n        在打包的时候，我们如果想将css分离出来，就需要使用到mini-css-extract-plugin 插件。\n        npm install -D mini-css-extract-plugin\n\n        //{ // 未分离css前\n           // test: /\\.css$/,\n           // use: [&#39;style-loader&#39;, &#39;css-loader&#39;,&#39;postcss-loader&#39;]\n        //},\n        { // 分离css后\n            test: /\\.css$/,\n            use: [\n                {\n                    loader: MiniCssExtractPlugin.loader\n                },\n                {\n                    loader: &#39;css-loader&#39;\n                },\n                {\n                    loader: &#39;postcss-loader&#39;\n                }\n            ]\n        },\n        { // 未分离css前\n            test: /\\.less$/,\n            use: [&#39;style-loader&#39;, &#39;css-loader&#39;, &#39;postcss-loader&#39;, &#39;less-loader&#39;]\n        },\n        { // 分离css后\n            test: /\\.less$/,\n            use: [\n                {\n                    loader: MiniCssExtractPlugin.loader\n                },\n                {\n                    loader: &#39;css-loader&#39;\n                },\n                {\n                    loader: &#39;postcss-loader&#39;\n                },\n                {\n                    loader: &#39;less-loader&#39;\n                }\n            ]\n        },\n        对loader做对应修改，并且在plugins中增加\n\n            new MiniCssExtractPlugin({\n                filename: &quot;css/[name].[hash:8].css&quot;,\n                chunkFilename: &quot;[id].css&quot;,\n            })\n\n        至此。一个vue的项目已经搭建完毕。\n\n        接下来我们添加vue-router和xuex</code></pre> <p>引入postcss之后，会出现 You did not set any plugins, parser, or stringifier. Right now, PostCSS does nothing. Pick plugins for your case on <a href="https://www.postcss.parts/">https://www.postcss.parts/</a> and use them in postcss.config.js.</p> <p>出现这个问题的原因是因为没有创建对应的postcss.config.js文件引起的。</p> <p>接下来我们创建postcss.config.js并添加配置（postcss如果需要浏览器自动补全css兼容前缀，需要autoprefixer这个插件） npm i autoprefixer -D</p> <pre><code>const autoprefixer = require(&#39;autoprefixer&#39;);\nmodule.exports = {\n    plugins: [\n        autoprefixer({\n            browsers:[&#39;&gt;0%&#39;]\n        })\n    ]\n};</code></pre> <p>这个时候重新启动项目。会出现 Replace Autoprefixer browsers option to Browserslist config. Use browserslist key in package.json or .browserslistrc file.这个错误</p> <p>按照错误在package.json中加入配置后重启。</p> <pre><code>&quot;browserslist&quot;: [\n    &quot;last 1 version&quot;,\n    &quot;&gt; 1%&quot;,\n    &quot;IE 10&quot;\n  ]</code></pre> <p>还会出现上述错误。</p> <p>Replace Autoprefixer browsers option to Browserslist config. Use browserslist key in package.json or .browserslistrc file.</p> <p> Using browsers option can cause errors. Browserslist config can be used for Babel, Autoprefixer, postcss-normalize and other tools.</p> <p> If you really need to use option, rename it to overrideBrowserslist.</p> <p>需要将postcss.config.js中之前使用的browsers更改为overrideBrowserslist 即可。</p> <pre><code>const autoprefixer = require(&#39;autoprefixer&#39;);\nmodule.exports = {\n    plugins: [\n        autoprefixer({\n            overrideBrowserslist:[&#39;&gt;0%&#39;]\n        })\n    ]\n};</code></pre> <p>这个时候发现，热更新失效了。。。。（一个坑结束之后，另一个坑又起。查了下原因，发现这个<a href="https://github.com/webpack/webpack-dev-server/issues/2758%EF%BC%89">https://github.com/webpack/webpack-dev-server/issues/2758）</a> 因为webpack5的target默认配置为web 告知 webpack 为目标(target)指定一个环境。默认值为 &quot;browserslist&quot;，如果没有找到 browserslist 的配置，则默认为 &quot;web&quot;</p> <p>解决办法： 1、将在package.json中配置的browserslist删除即可（显然不可能这么干，要不然上面的错误怎么解决呢） 2、在webpack.config.js文件中加入target: &quot;web&quot;即可</p> <pre><code>这里根据当前环境来target: process.env.NODE_ENV === &quot;development&quot; ? &quot;web&quot; : &quot;browserslist&quot;,\n\n1、配置环境变量。\n2、安装cross-env依赖（npm install cross-env -D）\n3、在package.json的启动修改为&quot;start&quot;: &quot;cross-env NODE_ENV=development webpack serve --config webpack.config.js&quot;\n\nnew webpack.DefinePlugin({\n    &#39;process.env.NODE_ENV&#39;: JSON.stringify(process.env.NODE_ENV || {})\n})</code></pre> <p>这个时候去修改单独的css文件（本例子中的styles目录下的文件），会发现，虽然会热更新起效果，但是修改后的样式并没有生效。 查了资料发现：<a href="https://www.jianshu.com/p/362a193645d6">https://www.jianshu.com/p/362a193645d6</a></p> <p>然后再webpack.config.js中的loader、css和less修改即可</p> <pre><code>process.env.NODE_ENV === &#39;development&#39; ? &#39;style-loader&#39; : MiniCssExtractPlugin.loader,\n// {\n//     loader: MiniCssExtractPlugin.loader\n// },</code></pre> <p>打包优化： <a href="https://www.bilibili.com/video/BV1jy4y1S7fy">https://www.bilibili.com/video/BV1jy4y1S7fy</a> <a href="https://blog.csdn.net/qq398577351/article/details/111525731">https://blog.csdn.net/qq398577351/article/details/111525731</a></p> <p>下面进行webpack优化部分：</p> <p>1、性能分析</p> <p>2、编译体积的优化</p> <p>3、编译时间优化</p> <p>4、运行优化</p> <h3 id="1、性能分析">1、性能分析</h3> <h4 id="11日志美化">1.1<a href="https://www.npmjs.com/package/friendly-errors-webpack-plugin">日志美化</a></h4> <pre><code>需要使用到以下两个插件(感觉挺鸡肋。还不如直接看控制面板的报错更直观)\nfriendly-errors-webpack-plugin // \nnode-notifier // 添加桌面通知</code></pre> <h4 id="21文件体积监控">2.1<a href="https://www.npmjs.com/package/webpack-bundle-analyzer">文件体积监控</a></h4> <pre><code>需要使用到以下插件(使用可以看npm文档)\nwebpack-bundle-analyzer \n并在package.json加入打包命令\n&quot;dev&quot;: &quot;webpack --profile&quot;。然后运行npm run dev 就能看到</code></pre> <h4 id="3-编译时间优化">3 编译时间优化</h4> <blockquote> <p>3.1 减少要处理的文件（时间 34:25）</p> <blockquote> <p>3.1.1 extensions(指定文件扩展名)</p> </blockquote> </blockquote> <blockquote> <blockquote> <p>3.1.2 alias(指定查找别名)</p> </blockquote> </blockquote> <blockquote> <blockquote> <p>3.1.3 modules 告诉 webpack 解析模块时应该搜索的目录</p> </blockquote> </blockquote> <pre><code>resolve:{\n    alias:{\n        &#39;vue$&#39;:&#39;vue/dist/vue.runtime.esm.js&#39;,\n        &#39;@&#39;:path.join(__dirname,&#39;src&#39;)\n    },\n    extensions: [&#39;.js&#39;, &#39;.vue&#39;, &#39;.json&#39;],\n},</code></pre> <blockquote> <blockquote> <p>3.1.4 <a href="https://webpack.docschina.org/configuration/module/#ruleoneof">oneof</a> rule.oneOf 规则匹配时，只使用匹配的第一个规则</p> </blockquote> </blockquote> <pre><code>在这个css和less的loader中，使用oneOf。打包的时间反而更长了。</code></pre> <blockquote> <blockquote> <p>3.1.5 <a href="https://webpack.docschina.org/configuration/externals/#root">externals 37:37</a> 使用外部引用[从输出的 bundle 中排除依赖，重而减小体积。可以将引入的echarts、vue、vuex、axios、element-ui等等]。</p> </blockquote> </blockquote> <pre><code>使用了echarts之后，启动的速度是43秒。使用外链之后，时间变为8秒。如果上述东西全部使用的话。最后时间\n其中在配置VueRouter的时候，会报Uncaught TypeError: Cannot redefine property: $router（无法重新定义属性：$ router）的错误\n\n这是因为我们在安装VueRouter的时候，与cdn引入造成重复引入\n\n解决办法是：在使用cdn的时候npm uninstall vue-router即可\n\nexternals: {\n    vue: &#39;Vue&#39;,\n    &#39;vue-router&#39;: &#39;VueRouter&#39;,\n    Vuex: &#39;vuex&#39;,\n    ElementUI: &#39;element-ui&#39;,\n}</code></pre> <blockquote> <blockquote> <p>3.1.6 <a href="https://webpack.docschina.org/concepts/#mode">module.noParse</a> 阻止webpack解析与给定正则表达式匹配的任何文件。被忽略的文件不应该有来电import，require，define或任何其他进口机制。忽略大型库时，这可以提高构建性能。</p> </blockquote> </blockquote> <blockquote> <blockquote> <p>3.1.7 <a href="https://webpack.js.org/plugins/ignore-plugin/#root">new webpack.IgnorePlugin</a> IgnorePlugin阻止生成与正则表达式或过滤器函数匹配的模块import或require调用：</p> </blockquote> </blockquote> <blockquote> <blockquote> <p>3.1.7 <a href="https://www.npmjs.com/package/thread-loader">thread-loader 多进程</a> IgnorePlugin阻止生成与正则表达式或过滤器函数匹配的模块import或require调用：</p> </blockquote> </blockquote> <blockquote> <p>3.2缩小查找的范围</p> <blockquote> <p>3.2.1 <a href="https://webpack.js.org/configuration/other-options/#cachecachedirectory">options中的cache</a> 缓存配置（loader中的options可配置，根目录下也可以）</p> </blockquote> </blockquote> <blockquote> <blockquote> <p>3.2.2 <a href="https://www.npmjs.com/package/cache-loader">cache-loader</a> 可以将一些性能开销较大的 缓存在磁盘中。默认帮寸在node_modules/.cache/cache_modules目录下</p> </blockquote> </blockquote> <blockquote> <blockquote> <p>3.2.3 hard-source-webpack-plugin 已在webpack5中内置了模块缓存，因此不需要使用。</p> </blockquote> </blockquote> <h4 id="4-编译体积优化">4 编译体积优化</h4> <blockquote> <p>压缩js、html、css、图片</p> </blockquote> <blockquote> <p><a href="https://www.npmjs.com/package/optimize-css-assets-webpack-plugin">optimize-css-assets-webpack-plugin</a> 优化和压缩css资源的插件</p> </blockquote> <blockquote> <p><a href="https://www.npmjs.com/package/terser-webpack-plugin">terser-webpack-plugin</a> 多进程/多实例 优化和压缩js资源的插件（webpack4需要安装，webpack5内置了）</p> </blockquote> <blockquote> <p><a href="https://www.npmjs.com/package/image-webpack-loader">image-webpack-loader</a> 优化和压缩图片资源的插件</p> </blockquote> <blockquote> <p>[html-webpack-plugin] 可以配置去空格等。</p> </blockquote> <blockquote> <p><a href="https://www.npmjs.com/package/purgecss-webpack-plugin">purgecss-webpack-plugin</a> 干掉无用的css</p> </blockquote> <blockquote> <p><a href="https://webpack.docschina.org/guides/tree-shaking/#root">tree shaking</a> 通常用于描述移除 JavaScript 上下文中的未引用代码(dead-code)</p> </blockquote> <blockquote> <blockquote> </blockquote> </blockquote> <blockquote> <p><a href="https://webpack.docschina.org/plugins/module-concatenation-plugin/#root">Scope hoisting</a></p> </blockquote> <h3 id="5-mode默认是production-区分环境-9334的讲解">5 mode(默认是production) 区分环境 93:34的讲解</h3> <p>在webpack.config.js(node环境的) process.env.NODE_ENV 默认是undefined</p> <p>在代码中（比如main.js中打印）process.env.NODE_ENV 的默认值是production(和mode值一样)</p> <h4 id="51-mode的配置---mode和--env具体配置方法和说明">5.1 mode的配置 <a href="https://webpack.docschina.org/api/cli/#environment-options">--mode和--env具体配置方法和说明</a></h4> <pre><code>--mode： 定义 webpack 所需的 mode\n\n这里有个取mode的值的优先级：在命令行配置的--mode &gt; 在webpack.config.js配置的mode &gt; 默认的mode(production)</code></pre> <blockquote> <p>webpack的默认值为production</p> </blockquote> <blockquote> <p>webpack serve的默认值是development</p> </blockquote> <blockquote> <p>可以在模块内通过，process.env.NODE_ENV获取当前环境变量，无法在webpack配置文件中获取此变量</p> </blockquote> <pre><code>// 在package.json中的\nscript: {\n    &quot;testMode&quot;: &quot;webpack&quot;,\n    &quot;testMode1&quot;: &quot;webpack --mode=development&quot;\n}\n// 在webpack.config.js中加入打印\nconsole.warn(&#39;webpack.config.js的环境变量=&#39;, process.env.NODE_ENV)\n// 不论执行哪个npm run testMode或者npm run testMode1打印结果都一样\n// 打印结果：webpack.config.js的环境变量=, undefined\n\n// 在main.js中（入口文件）中加入打印\nconsole.warn(&#39;main=&#39;, process.env.NODE_ENV)\n// 打印结果为 npm run testMode 的打印结果为默认值production（如果配置文件没配mode的话,配了取配置的值）\n\n// 执行 npm run testMode1的打印结果为development（不论配置文件是否配置mode值，都取命令行的development）</code></pre> <pre><code>Warning\n注意，命令行接口（Command Line Interface）参数的优先级，高于配置文件参数。例如，如果将 --mode=&quot;production&quot; 传入 webpack CLI，而配置文件使用的是 development，最终会使用 production。</code></pre> <h4 id="52---env的配置和使用方法">5.2 <a href="https://webpack.docschina.org/guides/environment-variables/">--env的配置和使用方法</a></h4> <pre><code>--env： 当它是一个函数时，传递给配置的环境变量\n\n该配置和--mode一样，无法改变webpack.config.js中打印的process.env.NODE_ENV的值。\n只能在回调中使用\n\n修改 package: &quot;testDev&quot;: &quot;webpack --env NODE_ENV=local --env TEST=test&quot;\n\n修改webpack.config.js配置\n\nmodule.exports = env =&gt; {\n    console.log(&#39;--dev&#39;, env)\n    // 执行npm run testDev\n    // --dev { WEBPACK_BUNDLE: true, NODE_ENV: &#39;local&#39;, TEST: &#39;test&#39; }\n    return {\n\n    };\n};</code></pre> <h4 id="53-定义全局变量--允许在-编译时-创建配置的全局常量">5.3 <a href="https://webpack.docschina.org/plugins/define-plugin/">定义全局变量</a>: 允许在 <strong>编译时</strong> 创建配置的全局常量</h4> <pre><code>new webpack.DefinePlugin({ \n    // 定义在编译阶段使用的全局变量，在浏览器运行阶段就只是个值\n    &#39;test&#39;: JSON.stringify(&#39;test&#39;)\n})\n\n同样的，该配置只能配置打包过程中的变量，对于webpack.config.js中依旧是访问不到的</code></pre> <h4 id="54-cross-env插件-跨操作系统设置环境变量">5.4 <a href="https://www.npmjs.com/package/cross-env">cross-env插件</a>: 跨操作系统设置环境变量</h4> <pre><code>&quot;start&quot;: &quot;cross-env NODE_ENV=development TEST=test webpack serve --config webpack.config.js&quot;,\n\n\n这个只会影响webpack.config.js文件内的process.env的值。\n\nconsole.log(process.evn.NODE_ENV, process.evn.TEST) // development, test</code></pre> <h3 id="6-代码分割">6 代码分割</h3> <p>6.1 入口点分割（多入口文件配置）</p> <p>6.2 懒加载（动态import）</p> <blockquote> <p>用户需要什么功能就只加载这个功能对应代码，也就是所谓的按需加载，在给单页面应用做按需加载优化时一般采用以下原则：</p> </blockquote> <blockquote> <blockquote> <p>1、对网站功能进行划分，每一个类一个chunk</p> </blockquote> </blockquote> <blockquote> <blockquote> <p>2、对于首次打开页面需要的功能直接加载，某些依赖大量代码的功能点可以按需加载</p> </blockquote> </blockquote> <blockquote> <blockquote> <p>3、被分割出去的代码需要一个按需加载的时间</p> </blockquote> </blockquote> <p>6.3 prefetch</p> <blockquote> <p>使用预先拉取，表示该模块可能以后会用到。浏览器会在空闲的时候下载该模块。</p> </blockquote> <blockquote> <p>prefetch 的作用就是告诉浏览器未来可能会用到该资源，</p> </blockquote> <p>prefetch 预获取（浏览器空闲加载。没用性能问题）</p> <p>preload 预加载（预加载，肯定会用到，需要提前获取。在首页慎用，会引起性能隐患）</p> <p>6.4 split chunks plugins 79:00</p> <h3 id="7-babel">7 babel</h3> <p>@babel/preset-env默认只转化新的javascript语法，而不转化新的api,比如Iterator、Generator、Set、Map、Proxy、Reflect、Symbol、Promise,以及一些在全剧对象上的方法Object.assign</p> <p>比如ES6在Array对象上新增Array.form方法。babel不会转化这个，需要使用babel-polyfill（polyfill：垫片）来转化</p> <p>@babel-polyfill 会污染全局变量。</p> <p>@babel-runtime 解决全局空间污染的问题， 提供编译模块的工具函数 更像一种按需加载的实现</p> <p>polyfill service</p> '}},o={};function n(t){if(o[t])return o[t].exports;var s=o[t]={exports:{}};return e[t](s,s.exports,n),s.exports}n.n=e=>{var o=e&&e.__esModule?()=>e.default:()=>e;return n.d(o,{a:o}),o},n.d=(e,o)=>{for(var t in o)n.o(o,t)&&!n.o(e,t)&&Object.defineProperty(e,t,{enumerable:!0,get:o[t]})},n.o=(e,o)=>Object.prototype.hasOwnProperty.call(e,o),(()=>{"use strict";var e=n(77),o=n.n(e);console.log(o()),document.write(o())})()})();